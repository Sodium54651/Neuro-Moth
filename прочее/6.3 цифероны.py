import numpy as np 


Data = np.array([
                [2, 7], 
                [8, 5], 
                [6, 6]
                ])

Answers = np.array([
                    [4], 
                    [40], 
                    [36]
                    ])

# для начала запишем все наши значения, так умножение, мы строку на столбик, значит инвертируем, строну на строку
# так для начала идёт строка, значит пишем сколько у нас толбиков в матрице 3 значит 3 и значения 2, 
# хотя погоди, для начала сколько у нас будет нейрончиков 1 значит 1, сколько на вход 2 значения значит 2.
w = np.random.rand(3, 2)
bias = 0.0

z = Data @ w.T + bias

w1 = np.random.rand(1, 3)
bias1 = 0.0

NAnswers = z @ w1.T + bias
LR = 0.01
for rh in range(1000):
    # ищем насколько мы ошиблись и куда идти как методом дихотомии
    loss = NAnswers - Answers

    # теперь делаем градиент, так для начала мы должны умножить массив с данными на наш ответ, так ответ
    # сколько куда что бы что? так ответ должен быть таким же как ответ ответ, значит, 3 строки 1 значение
    # у нас 3 строки 2 значения, значит, строка на столбик надо что бы было 3 на 3 значит просто умножаем
    # а вообще погоди так нам нужно не просто перемножить а так что бы ответы задевали только значения значений
    # значит надо вот покрутить массив что бы он, получается вот так, так получается что он идёт на бочёк
    # 2 8 6, на 4 и так далее, это означает, что мы часть от всего говна умножаем на общий ответ, или наоборот
    w1G = loss.T @ z
    # теперь смещение оно, оно должно быть сумме всех разничных ответиков
    bias1G = np.sum(loss)

    wG = loss.T @ Data
    biasG = bias1G
    # подкручиваем веса
    w1 -= w1G * LR
    bias1 -= bias1G * LR

    w -= wG * LR
    bias -= biasG * LR
    NAnswers = Data @ w.T + bias
    print(NAnswers)
