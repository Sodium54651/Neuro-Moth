import numpy as np 

# возвращает массив того же размера только отсеивает все промежуточные даннные что у тебя не правильны
# со стороны подсчётов нейросети
# смотри это всёровно что тебе сказали что вот эта часть мыслей у тебя не правильна я не знаю какая 
# но точно не верная давай мы её учитывать не будем и заменяем все значения на ничего ну типо с нулём 
# никаких действий не сделаешь я про умножение умножишь и прибавишь ничего отлично
def Relu(z):
    return np.maximum(0, z)

# вводим данные 
Data = np.array([
    [8, 9],   # очень голоден и устал → 1
    [1, 2],   # не голоден, не устал → 0
    [7, 3],   # голоден, но не очень устал → ?
    [0, 9]    # не голоден, но устал → ?
])
Answers = np.array([
    [1],
    [0],
    [1],
    [0]
])

# записываем рандомные значения для весов первый парамерт это сколько у тебя будет нейрончиков 3, сколько у тебя
# данных у меня их 2 ну типо данных значения в одном массиве всего 2 значит 2
# w = np.random.rand(3, 2)
# а теперь я попробую всё посчитать на бумажке
w = np.array([
    [1, 2],
    [-3, 4],
    [-9, 5]
])
bias = np.array([
    [0, 0, 0]
])
# он должем инметь значения что бы расположить на все нейрончики тобишь всего 3 на столбика
# bias = np.random.rand(1, 3)

# это и есть скрытый слой его не видно шарики что между входом и выходом
# теперь записываем это всё в формулку что будет производить действия, ну смотри с первой полоской шариков
# что обычно на рисунке у тебя их всего 3 это всё
z1 = Data @ w.T + bias 
# для бумажных данных = +
print(z1)
print()




# проверяем значения на то испорченные ли они
a1 = Relu(z1)
print(a1)
print()
# на бумажке данные = +
# print(a1)
# теперь мы записываем сигмоид sigmoid эта штука сумирует все мысли что накопились из общего бульёна мыслей
# но для начала нужно задать уже другие веса и другую плату за воздух
# смотри ещё раз как генерируется w тут 1 это сколько у тебя колличество нейрончико опять же ну типо
# 1 выходной думаю понятно, и 3 параметра у каждого, почему? а потому что ты принимаешь у же не типо
# массивы а типо данны, я сам уже запутался, но получается что мы сделали 3 нейрона и получили у них данные о
# 3 короче там у массива данные повернулись и стало по столбцам 3, типо 3 нейрона нажевали типо так да
# и получается так что нейроны мы получаем уже данные не как бы о самих данных с начала, а получаем 
# данные уже с самих нейрончиков, типо подвести итоги
# w1 = np.random.rand(1, 3)
# bias1 = np.random.rand(1, 1)
# тоже делаем на бумажке
w1 = np.array([
    [1, 1, 2]
])
bias1 = np.array([
    [0]
])
out = a1 @ w1.T + bias1
print(out)
print()
# так бумажка данные = +-
# что бы мысли нейросети перешло в понятный вид
# это смотри всёровно что прочесть мысли и так как там набор данных нифига не понятно, но мы 
# их переводим в понятный для человека
# для этого мы берём данные что получились до этого, потом делаем так что бы они были в види экспоннты
# это что бы данные были собранные в кучу, потом прибавляем 1 делаем так что бы они были не такие неебически
# маленькими и делим от единицы, что бы получить значение между 0 и единицы.
print(1 / (1 + np.exp(- out)))