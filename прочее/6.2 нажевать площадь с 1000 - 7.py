import numpy as np 

def Relu(z):
    return np.maximum(0, z)

def pip(x):
    print("=" * 32)
    print(x)

Data = np.array([
    [2, 2],
    [4, 5],
    [3, 2],
    [2, 3]
])

Answers = np.array([
    [4],
    [20],
    [6],
    [6]
])

# теперь запишем все наши начальные значения входные данные из 4 строчек по 2 значения, 3 нейрончика по 2 отсека
# входа, 1 выходной нейрончик с 3 входиками
w0 = np.random.rand(3, 2)
b0 = np.random.rand(1, 3)

w1 = np.random.rand(1, 3)
b1 = np.random.rand(1, 1)
# добавим смещение 0.01
LR = 0.01

for rh in range(1000):

    print("===> ", rh+1)
    z1 = Data @ w0.T + b0
    a1 = Relu(z1)
    # print(a1)
    NAnswer = a1 @ w1.T + b1
    # print(NAnswer)
    # вот теперь уже начинается полная жопа пока считаем потери
    loss = NAnswer - Answers
    print(loss)
    # теперь мы подгоняем выходные нейроны и смотрим насколько ошиблись и в какую сторону нам двигаться
    # print(a1)
    w1G = loss @ a1
    b1G = loss

    # теперь подгоняем смотрим что не так в нашем ответе от скрытый нерончиков типо смотри у нас есть ответы 
    # мы примем x ответы как правильны ну прям инфа соточка а теперь ты просто высиськовываешь их и находишь 
    # относительно ответом просто задачка с x
    
    a1G = loss @ w1
    z1G = a1G * (z1 > 0)
    print(a1G)
    pip(z1G)
    # pip(loss)
    # теперь уже по ответам подгоняем на сколько были правдивы весы
    w0G = z1G.T @ Data
    pip(w0G)
    b0G = z1G

    # теперь мы подкорриектируем наши значения весов и платы за воздух с шагом
    w1 = w1 - LR * w1G
    pip(b1G)
    b1 -= np.sum(LR * b1G)

    w0 -= LR * w0G 
    b0 -= LR * np.sum(LR * b1G)












