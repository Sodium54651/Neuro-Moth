import numpy as np
P = np.arange(4, 9) * 10
KUta = np.array([1, 2, 3, 3])
Coast = np.array([4.5, 6.0, 7.2, 9.0])

# X = np.array(np.ones([1, 4]), P, KUta)
# print(X)
X = np.array([[1, 40, 1], 
             [1, 50, 2],
             [1, 60, 3],
             [1, 80, 3]])
# единица, площадь, комнаты
w = np.linalg.inv(X.T @ X) @ X.T @ Coast
print(w)
# чесно я не знаю что за залупу получил но вот
# такие циферки [0.575  0.0875 0.475 ], нихуя не поняно, хорошо давай зайдём с другой стороны как мат саститсики
# как бы я сделал, ну смотри для начала я бы дал каждому показателю свой коффициент, что вот типо площадь 
# бы была на столько её положение по стране столько может тут так же хорошо, тогда почему 3 показателя если нам 
# дали всего 2 площадь и колличество комнат, а может последний ито и есть цена? ну хуй знает сейчас проверим

# X = np.array([1, 70, 2])

# а что мне надо сделать для итого, ну смотри я получил параметры чего то, но хуй знает чего
# если вычислять обратно по формуле получается ооочень больно я не буду итого делать
# да и не получится потому что параметров уже больше ну потому что массив из стольки состоит а я буду 
# пытаться нажевать тутда ещё значения которых не было изначально
 
# хорошо я произвёл немного поисков "как по висам предсказать число", как я понял ито часть типо вероятности
# чего то, ответа, то есть ито вероятность того, что программа уверена на то что... что в чём она уверена точно?
# нихуя не понятно, тогда по такой теории получается что программа не уверена в том, что я ей только что ввёл
# хуйня какая то, ну смотри, а если ито вероятность только чего то друго ну не знаю.

# так хорошо давай посмотрим с внутренней стороны что делает формулку, она делает какую то магию верно верно
# а что имеенно, давай ка постепенно. У нас в формулке что мы делаем действия с площадью и 
# числом комнат, они там обрабатываются и уножаются на значение у, тааааааак, давай 
# посмотрим какую роль играет вот ита часть с площадями
print()
print(np.linalg.inv(X.T @ X) @ X.T)
print()
print(np.linalg.inv(X.T @ X))
print()
print((X.T @ X))

# так смотри что я заметил, вот ито то что 1 штука при умножении
# у нас получается не ебическое кооличества циферок большая 
# часть из которых вообще меньще 1 дальше убираем, 2 принт, 
# получаем то, что циферок ровно столько что было в самом начале но НО! массив нет он сатал меньше 
# у него не те значения что были он как то его пересиськовал, их стало меньше, значит часть данных
# пересиськовалась в другие совсем последняя ито всё пошло отседого мы что то сделали при умножении
# после трансвестирования точно, потому что трансвестирование ито просто перевернуть.

print()
print(X.T)

# опа смотри если я посмотрю что произошло да он просто да он просто перевернул массив с данными, а как умножение 
# он его умножает и получаются такие данные хорошо ничего особенного запустим ещё раз но в другом порядке, с 
# разжёвыванием что за что делает

print("первая")
print(X.T)
print()
print((X.T @ X))
print()
print(np.linalg.inv(X.T @ X))
print()
print(np.linalg.inv(X.T @ X) @ X.T)

# ладно хорошо попрежнему нихуя не понятно что он делает он как то обрабатывает данные 
# а потом их сиськует с готовым ответом ито точно понятно, значит мы в конце сравниваем с ответом, и получаем
# данные значит данные ито процесс того что наша программа нашла бля я нихуя не понял я забыл что за дание 
# было

# цена воздуха, площадь, комнаты.
X1 = np.array([1, 70, 2])
print(X1 * w)
print(np.sum(X1 * w))

# я узнал примерную стоимость квартиры с такими значениями
